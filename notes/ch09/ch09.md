# 内存模型和名称空间

## 单独编译
- 头文件不会被编译，源文件中的#include预编译指令会将包含的头文件替换
- 同一个文件中只能将头文件包含一次，使用#pragma once或者#ifndef #endif来处理
- 头文件中包含的内容
    - 函数原型
    - 使用#define或const定义的符号常量
    - 结构声明
    - 类声明
    - 模板声明
    - 内联函数

## 存储持续性、作用域及链接性

| 变量类型 | 存储持续性 | 作用域 | 链接性 | 如何声明 |
|:-:|:-:|:-:|:-:|:-:|
|自动变量| 自动存储持续性 | 代码块 | 无 | 在代码块中 |
|静态，无链接性| 静态存储持续性 | 代码块 | 无 | 在代码块中，使用static |
|静态，外部链接性| 静态存储持续性 | 文件 | 外部 | 不在任何函数内 |
|静态，内部链接性| 静态存储持续性 | 文件 | 内部 | 不在任何函数内 |

- 存储持续性 - 数据在内存中存在的时间
- **外部链接性**，可在其他文件中访问，**内部链接性**，只能在当前文件中访问
- 单定义规则，变量只能有一次定义。将变量声明分为定义(声明)（分配空间）和(引用)声明。引用声明使用关键字extern，不分配空间，用于全局变量
- 存储说明符，不能重复使用：auto, register, static, extern, thread_local, mutable
    - mutable说明即使结果变量为const，某个成员也可以被修改
- cv限定符: const; volatile
    - const全局变量的链接性为内部，如果多个源文件包含同一个有const全局变量的头文件，相当于每个源文件定义了自己的常量
    - extern可以覆盖const全局变量的默认内部链接性： extern const int states = 50, 此时使用该变量的其他文件中必须使用extern
- 声明区域 - 可以在其中进行声明的区域
- 潜在作用域 - 从声明点开始到声明区域的结尾
- 作用域 - 变量对程序可见的范围，例如嵌套的代码块中声明的变量会覆盖全局变量
- 静态变量初始化
    - 零初始化（静态），所有静态变量都会先被编译器零初始化
    - 常量初始化（动态），如果编译器能根据文件内容（包括包含的头文件）就能计算，会在零初始化后执行常量初始化
    - 动态初始化，等到链接且程序执行时
- 定位new运算符
    - 包含头文件new

![new](./new.png)
### 名称空间 - 不能位于代码块中
- 全局名称空间，文件级声明区域，全局变量位于其中
- 默认在名称空间中声明的变量为外部变量，除非其引用常量
- using声明和using编译指令
