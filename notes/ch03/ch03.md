# **第三章 处理数据**

- *OOP的本质是使用c++内置类型设计并扩展自己的数据类型*
- *c++内置类型 - 基本类型和复合类型*
- *两种基本类型 - 整型和浮点型*
- *使用变量来标识存储的数据*

## **简单变量**
- 声明变量解决的三个问题：信息将存储在哪里（内存单元标记为变量名）；存储什么值；存储何种类型的信息
- 变量名命名规则
    - 名称中只能使用字母，数字和下划线
    - 第一个字符不能是数字
    - 区分大小写
    - 不能将c++关键字用作名称
    - 两个下划线，一个下划线+大写字母的名称保留给实现（编译器）
    - 一个下划线开头保留给实现用作全局标识符
    - 注意长度限制
- 整型
    - byte字节通常指8bit内存单元
    - (unsigned) char专为存储字符（如字母和数字）
        - 转义字符，符合转义序列，八进制和十六进制编码的转义序列('\032', "hi\xla there")
        - 通用字符(Unicode)，\u+8个16进制位, \U+16个16进制位，一个16进制位为4个bit，如\u00F6
        - 默认不是有符号或者无符号，是否有符号由实现决定
        - 存储标准ANSII字符有无符号没关系
        - wchar_t宽字符，加前缀L表示宽字符（串）： wchar_t bog = L'P'. 宽字符取决于实现，例如一个系统是unsigned short，另一个是int
        - c++ 11增加了char16_t（加前缀u）和char32_t（加前缀U），用来表征unicode: char16_t ch1 = u'q'
    - (unsigned) short至少16位，通常用于大型正型数组
    - (unsigned) long至少32位，如果数值大于16位整数用long，即使int为32位
    - (unsigned) long long至少64位，c++11新增
    - (unsigned) int至少与short一样长，被设置为目标计算机的自然长度，没有其他理由选int
    - c++确保无符号类型超出限制（上溢和下溢）则将为范围另一端的取值，但不保证符合整形超越限制不出错
    - 第一位为1-9为10进制，第一位为0第二位为1-7为八进制，0x或0X为16进制
    - **常量**默认为int，后缀l/ul/L/UL/ll/LL/ull/Ull/uLL/ULL等表示不同类型，22022LU/22022UL
    - **cout.put()** 处理c++ release 2.0之前将字符常量(如'M')存储为int，导致cout<<'M'打印对应ASCII码的问题
- bool型，非零值解释为ture，零解释为false，true可提升转换为1，false提升转换为0
- 浮点型
    - 存储时一部分表示值，一部分表示缩放（2的幂）
    - 两种表示法，标准小数点（12.34）和E表示法（2.53e6，e前小数点可选，e也可以是E，e后的符号可以是+/-/没有，e后面数字表示1后面几个0）
    - 浮点常数默认为double，float型需要用f或F后缀，long double型用l或L后缀
- 算术运算法
    - 五个基本运算符: +, -, *, /（如果两个操作数为整数，小数部分被丢弃）, %（浮点数会导致编译错误）
    - 优先级和结合性一起判断优先级（同一优先级要看操作数从右结合还是从左结合）
- 自动类型转换
    - 将一种算术类型的值赋给另一种算术类型的值时，值被转换为接收变量的类型
        - 较大浮点转换为较小浮点精度降低
        - 浮点转化为整型，小数一定丢失，超出范围则结果不确定
        - 较大整型转换为较小整型，超出范围只复制右边字节
        - *列表初始化见下面内容*
    - 表达式中包含不同的类型时
        - 整型提升，计算表达式时，bool/char/unsigned char/signed char/short转换为int
        - 如果一个操作数是long double则将另一个操作室转换为long double
        - 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double
        - 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float
        - 否则，如果操作数都是整型，执行整型提升
            - 如果两个操作数都是有符号或无符号的，且其中一个比另一个低，转换为级别高的类型
            - 如果一个操作数有符号，一个无符号，且无符号的级别比有符号的高，将有符号转换为无符号操作数的类型
            - 否则，如果有符号类型可以表示无符号类型的所有可能取值，则无符号转换为有符号操作数所属类型
            - 如走，将两个操作数都转换为有符号类型的无符号版本
    - 将参数传递给函数时
- 强制类型转换
    - (typeName) value 或者 typeName (value)， 第二种为c++，为了让强制类型转换像函数调用
- sizeof运算法返回类型或变量的长度, 类型名需放到括号中sizeof(int)，变量名可选sizeof n_short
- const限定符，要求变量声明时进行初始化：const int Months = 12
    - 能制定类型
    - 能限制作用域
    - 能用于更复杂类型
- 头文件climits定义了符号常亮来表示类型的限制
- #define INT_MAX 32767，编译指令告诉预处理器，在程序中查找INT_MAX并替换位32767
- 初始化将赋值和声明合并在一起, 如果知道变量初始值应该是多少则应该进行初始化
    - 经典c: int owls = 101;
    - c++: int wrens(432);
    - c++98可用大括号初始化单值变量：int hamburgers = {24};
    - c++11扩展大括号，即列表初始化
        - 可以使用等号，也可不用：int emus{7};
        - 大括号内不包含任何东西则变量被初始化为0：int rocs = {}
        - 可预防类型转换错误
            - 不允许缩窄
            - 编译器确认目标变量可以正确赋值允许整型之间转换或整型变为浮点型
        - 让初始化类变量和常规结构的方式相似，*便于学习*
- auto处理复杂类型时，用来进行自动类型推断
